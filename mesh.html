<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>pyxyz.mesh API documentation</title>
<meta name="description" content="Mesh class definition" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyxyz.mesh</code></h1>
</header>
<section id="section-intro">
<p>Mesh class definition</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Mesh class definition&#34;&#34;&#34;
import math
import pygame
from pyxyz.vector3 import Vector3

class Mesh:
    &#34;&#34;&#34;Mesh class.
    Stores a list of polygons to be drawn
    &#34;&#34;&#34;
    stat_vertex_count = 0
    &#34;&#34;&#34;Vertex count for statistics. This code that actually tracks the statistics
    is normally commented out for performance reasons (see render method)&#34;&#34;&#34;
    stat_transform_time = 0
    &#34;&#34;&#34;Time spent on vertex transforming for statistics. This code that actually tracks
    the statistics is normally commented out for performance reasons (see render method)&#34;&#34;&#34;
    stat_render_time = 0
    &#34;&#34;&#34;Time spent in rendering for statistics. This code that actually tracks the statistics
    is normally commented out for performance reasons (see render method)&#34;&#34;&#34;

    def __init__(self, name=&#34;UnknownMesh&#34;):
        &#34;&#34;&#34;
        Arguments:

            name {str} -- Name of the material, defaults to &#39;UnknownMesh&#39;
        &#34;&#34;&#34;
        self.name = name
        &#34;&#34;&#34; {str} Name of the mesh&#34;&#34;&#34;
        self.polygons = []
        &#34;&#34;&#34; {list[list[Vector3]]} List of lists of polygons. A polygon is a closed shape,
        hence the need for a list of lists, if we want more complex shapes.&#34;&#34;&#34;

    def offset(self, v):
        &#34;&#34;&#34;
        Offsets this mesh by a given vector. In practice, adds v to all vertex in all polygons

        Arguments:

            v {Vector3} -- Ammount to displace the mesh
        &#34;&#34;&#34;
        new_polys = []
        for poly in self.polygons:
            new_poly = []
            for p in poly:
                new_poly.append(p + v)
            new_polys.append(new_poly)

        self.polygons = new_polys

    def render(self, screen, clip_matrix, material):
        &#34;&#34;&#34;
        Renders the mesh.

        Arguments:

            screen {pygame.surface} -- Display surface on which to render the mesh

            clip_matrix {np.array} -- Clip matrix to use to convert the 3d local space coordinates
            of the vertices to screen coordinates.

            material {Material} -- Material to be used to render the mesh

            Note that this function has the code that tracks statistics for the vertex count and
            render times, but it is normally commented out, for performance reasons. If you want
            to use the statistics, uncomment the code on this funtion.
        &#34;&#34;&#34;
        # Convert Color to the pygame format
        c = material.Color.tuple3()

        # For all polygons
        for poly in self.polygons:
            # Create the list that will store (temporarily) the transformed vertices
            tpoly = []
            # Uncomment next 2 lines for statistics
            #Mesh.stat_vertex_count += len(poly)
            #t0 = time.time()
            for v in poly:
                # Convert the vertex to numpy format and multiply it by the clip matrix
                vout = v.to_np4()
                vout = vout @ clip_matrix

                # Finalize the transformation by converting the point from homogeneous NDC to
                # screen coordinates (divide by w, scale it by the viewport resolution and
                # offset it)
                tpoly.append((screen.get_width() * 0.5 + vout[0] / vout[3],
                              screen.get_height() * 0.5 - vout[1] / vout[3]))

            # Uncomment next line for statistics
            #t1 = time.time()

            # Render
            pygame.draw.polygon(screen, c, tpoly, material.line_width)

            # Uncomment next 3 lines for statistics
            #t2 = time.time()
            #Mesh.stat_transform_time += (t1 - t0)
            #Mesh.stat_render_time += (t2 - t1)

    @staticmethod
    def create_cube(size, mesh=None):
        &#34;&#34;&#34;
        Adds the 6 polygons necessary to form a cube with the given size. If a source mesh is
        not given, a new mesh is created.
        This cube will be centered on the origin (0,0,0).

        Arguments:

            size {3-tuple} -- (x,y,z) size of the cube

            mesh {Mesh} -- Mesh to add the polygons. If not given, create a new mesh

        Returns:
            {Mesh} - Mesh where the polygons were added
        &#34;&#34;&#34;

        # Create mesh if one was not given
        if mesh is None:
            mesh = Mesh(&#34;UnknownCube&#34;)

        # Add the 6 quads that create a cube
        Mesh.create_quad(Vector3(size[0] * 0.5, 0, 0),
                         Vector3(0, -size[1] * 0.5, 0),
                         Vector3(0, 0, size[2] * 0.5), mesh)
        Mesh.create_quad(Vector3(-size[0] * 0.5, 0, 0),
                         Vector3(0, size[1] * 0.5, 0),
                         Vector3(0, 0, size[2] * 0.5), mesh)

        Mesh.create_quad(Vector3(0, size[1] * 0.5, 0),
                         Vector3(size[0] * 0.5, 0),
                         Vector3(0, 0, size[2] * 0.5), mesh)
        Mesh.create_quad(Vector3(0, -size[1] * 0.5, 0),
                         Vector3(-size[0] * 0.5, 0),
                         Vector3(0, 0, size[2] * 0.5), mesh)

        Mesh.create_quad(Vector3(0, 0, size[2] * 0.5),
                         Vector3(-size[0] * 0.5, 0),
                         Vector3(0, size[1] * 0.5, 0), mesh)
        Mesh.create_quad(Vector3(0, 0, -size[2] * 0.5),
                         Vector3(size[0] * 0.5, 0),
                         Vector3(0, size[1] * 0.5, 0), mesh)

        return mesh

    @staticmethod
    def create_sphere(size, res_lat, res_lon, mesh=None):
        &#34;&#34;&#34;
        Adds the polygons necessary to form a sphere with the given size and resolution.
         If a source mesh is not given, a new mesh is created.
        This sphere will be centered on the origin (0,0,0).

        Arguments:

            size {3-tuple} -- (x,y,z) size of the sphere
            or
            size {number} -- radius of the sphere

            res_lat {int} -- Number of subdivisions in the latitude axis

            res_lon {int} -- Number of subdivisions in the longitudinal axis

            mesh {Mesh} -- Mesh to add the polygons. If not given, create a new mesh

        Returns:
            {Mesh} - Mesh where the polygons were added
        &#34;&#34;&#34;
        # Create mesh if one was not given
        if mesh is None:
            mesh = Mesh(&#34;UnknownSphere&#34;)

        # Compute half-size
        if isinstance(size, Vector3):
            hs = size * 0.5
        else:
            hs = Vector3(size[0], size[1], size[2]) * 0.5

        # Sphere is going to be composed by quads in most of the surface, but triangles near the
        # poles, so compute the bottom and top vertex
        bottom_vertex = Vector3(0, -hs.y, 0)
        top_vertex = Vector3(0, hs.y, 0)

        lat_inc = math.pi / res_lat
        lon_inc = math.pi * 2 / res_lon
        # First row of triangles
        lat = -math.pi / 2
        lon = 0

        y = hs.y * math.sin(lat + lat_inc)
        c = math.cos(lat + lat_inc)
        for _ in range(0, res_lon):
            p1 = Vector3(c * math.cos(lon) * hs.x, y, c * math.sin(lon) * hs.z)
            p2 = Vector3(c * math.cos(lon + lon_inc) * hs.x, y, c * math.sin(lon + lon_inc) * hs.z)

            Mesh.create_tri(bottom_vertex, p1, p2, mesh)

            lon += lon_inc

        # Quads in the middle
        for _ in range(1, res_lat - 1):
            lat += lat_inc

            y1 = hs.y * math.sin(lat)
            y2 = hs.y * math.sin(lat + lat_inc)
            c1 = math.cos(lat)
            c2 = math.cos(lat + lat_inc)

            lon = 0
            for _ in range(0, res_lon):
                p1 = Vector3(c1 * math.cos(lon) * hs.x,
                             y1,
                             c1 * math.sin(lon) * hs.z)
                p2 = Vector3(c1 * math.cos(lon + lon_inc) * hs.x,
                             y1,
                             c1 * math.sin(lon + lon_inc) * hs.z)
                p3 = Vector3(c2 * math.cos(lon) * hs.x,
                             y2,
                             c2 * math.sin(lon) * hs.z)
                p4 = Vector3(c2 * math.cos(lon + lon_inc) * hs.x,
                             y2,
                             c2 * math.sin(lon + lon_inc) * hs.z)

                poly = []
                poly.append(p1)
                poly.append(p2)
                poly.append(p4)
                poly.append(p3)

                mesh.polygons.append(poly)

                lon += lon_inc

        # Last row of triangles
        lat += lat_inc
        y = hs.y * math.sin(lat)
        c = math.cos(lat)
        for _ in range(0, res_lon):
            p1 = Vector3(c * math.cos(lon) * hs.x, y, c * math.sin(lon) * hs.z)
            p2 = Vector3(c * math.cos(lon + lon_inc) * hs.x, y, c * math.sin(lon + lon_inc) * hs.z)

            Mesh.create_tri(top_vertex, p1, p2, mesh)

            lon += lon_inc

        return mesh


    @staticmethod
    def create_quad(origin, axis0, axis1, mesh):
        &#34;&#34;&#34;
        Adds the vertices necessary to create a quad (4 sided coplanar rectangle).
        If a source mesh is not given, a new mesh is created.

        Arguments:

            origin {Vector3} -- Center of the quad

            axis0 {Vector3} -- One of the axis of the quad. This is not normalized, since the
            length specifies half the length of that side along that axis

            axis1 {Vector3} -- One of the axis of the quad. This is not normalized, since the
            length specifies half the length of that side along that axis

            mesh {Mesh} -- Mesh to add the polygons. If not given, create a new mesh

        Returns:
            {Mesh} - Mesh where the polygons were added
        &#34;&#34;&#34;
        if mesh is None:
            mesh = Mesh(&#34;UnknownQuad&#34;)

        poly = []
        poly.append(origin + axis0 + axis1)
        poly.append(origin + axis0 - axis1)
        poly.append(origin - axis0 - axis1)
        poly.append(origin - axis0 + axis1)

        mesh.polygons.append(poly)

        return mesh

    @staticmethod
    def create_tri(p1, p2, p3, mesh):
        &#34;&#34;&#34;
        Adds the vertices necessary to create a triangle
        If a source mesh is not given, a new mesh is created.

        Arguments:

            p1 {Vector3} -- First vertex of the triangle

            p2 {Vector3} -- Second vertex of the triangle

            p3 {Vector3} -- Third vertex of the triangle

            mesh {Mesh} -- Mesh to add the polygons. If not given, create a new mesh

        Returns:
            {Mesh} - Mesh where the polygons were added
        &#34;&#34;&#34;
        if mesh is None:
            mesh = Mesh(&#34;UnknownQuad&#34;)

        poly = []
        poly.append(p1)
        poly.append(p2)
        poly.append(p3)

        mesh.polygons.append(poly)

        return mesh</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyxyz.mesh.Mesh"><code class="flex name class">
<span>class <span class="ident">Mesh</span></span>
<span>(</span><span>name='UnknownMesh')</span>
</code></dt>
<dd>
<div class="desc"><p>Mesh class.
Stores a list of polygons to be drawn</p>
<h2 id="arguments">Arguments</h2>
<p>name {str} &ndash; Name of the material, defaults to 'UnknownMesh'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Mesh:
    &#34;&#34;&#34;Mesh class.
    Stores a list of polygons to be drawn
    &#34;&#34;&#34;
    stat_vertex_count = 0
    &#34;&#34;&#34;Vertex count for statistics. This code that actually tracks the statistics
    is normally commented out for performance reasons (see render method)&#34;&#34;&#34;
    stat_transform_time = 0
    &#34;&#34;&#34;Time spent on vertex transforming for statistics. This code that actually tracks
    the statistics is normally commented out for performance reasons (see render method)&#34;&#34;&#34;
    stat_render_time = 0
    &#34;&#34;&#34;Time spent in rendering for statistics. This code that actually tracks the statistics
    is normally commented out for performance reasons (see render method)&#34;&#34;&#34;

    def __init__(self, name=&#34;UnknownMesh&#34;):
        &#34;&#34;&#34;
        Arguments:

            name {str} -- Name of the material, defaults to &#39;UnknownMesh&#39;
        &#34;&#34;&#34;
        self.name = name
        &#34;&#34;&#34; {str} Name of the mesh&#34;&#34;&#34;
        self.polygons = []
        &#34;&#34;&#34; {list[list[Vector3]]} List of lists of polygons. A polygon is a closed shape,
        hence the need for a list of lists, if we want more complex shapes.&#34;&#34;&#34;

    def offset(self, v):
        &#34;&#34;&#34;
        Offsets this mesh by a given vector. In practice, adds v to all vertex in all polygons

        Arguments:

            v {Vector3} -- Ammount to displace the mesh
        &#34;&#34;&#34;
        new_polys = []
        for poly in self.polygons:
            new_poly = []
            for p in poly:
                new_poly.append(p + v)
            new_polys.append(new_poly)

        self.polygons = new_polys

    def render(self, screen, clip_matrix, material):
        &#34;&#34;&#34;
        Renders the mesh.

        Arguments:

            screen {pygame.surface} -- Display surface on which to render the mesh

            clip_matrix {np.array} -- Clip matrix to use to convert the 3d local space coordinates
            of the vertices to screen coordinates.

            material {Material} -- Material to be used to render the mesh

            Note that this function has the code that tracks statistics for the vertex count and
            render times, but it is normally commented out, for performance reasons. If you want
            to use the statistics, uncomment the code on this funtion.
        &#34;&#34;&#34;
        # Convert Color to the pygame format
        c = material.Color.tuple3()

        # For all polygons
        for poly in self.polygons:
            # Create the list that will store (temporarily) the transformed vertices
            tpoly = []
            # Uncomment next 2 lines for statistics
            #Mesh.stat_vertex_count += len(poly)
            #t0 = time.time()
            for v in poly:
                # Convert the vertex to numpy format and multiply it by the clip matrix
                vout = v.to_np4()
                vout = vout @ clip_matrix

                # Finalize the transformation by converting the point from homogeneous NDC to
                # screen coordinates (divide by w, scale it by the viewport resolution and
                # offset it)
                tpoly.append((screen.get_width() * 0.5 + vout[0] / vout[3],
                              screen.get_height() * 0.5 - vout[1] / vout[3]))

            # Uncomment next line for statistics
            #t1 = time.time()

            # Render
            pygame.draw.polygon(screen, c, tpoly, material.line_width)

            # Uncomment next 3 lines for statistics
            #t2 = time.time()
            #Mesh.stat_transform_time += (t1 - t0)
            #Mesh.stat_render_time += (t2 - t1)

    @staticmethod
    def create_cube(size, mesh=None):
        &#34;&#34;&#34;
        Adds the 6 polygons necessary to form a cube with the given size. If a source mesh is
        not given, a new mesh is created.
        This cube will be centered on the origin (0,0,0).

        Arguments:

            size {3-tuple} -- (x,y,z) size of the cube

            mesh {Mesh} -- Mesh to add the polygons. If not given, create a new mesh

        Returns:
            {Mesh} - Mesh where the polygons were added
        &#34;&#34;&#34;

        # Create mesh if one was not given
        if mesh is None:
            mesh = Mesh(&#34;UnknownCube&#34;)

        # Add the 6 quads that create a cube
        Mesh.create_quad(Vector3(size[0] * 0.5, 0, 0),
                         Vector3(0, -size[1] * 0.5, 0),
                         Vector3(0, 0, size[2] * 0.5), mesh)
        Mesh.create_quad(Vector3(-size[0] * 0.5, 0, 0),
                         Vector3(0, size[1] * 0.5, 0),
                         Vector3(0, 0, size[2] * 0.5), mesh)

        Mesh.create_quad(Vector3(0, size[1] * 0.5, 0),
                         Vector3(size[0] * 0.5, 0),
                         Vector3(0, 0, size[2] * 0.5), mesh)
        Mesh.create_quad(Vector3(0, -size[1] * 0.5, 0),
                         Vector3(-size[0] * 0.5, 0),
                         Vector3(0, 0, size[2] * 0.5), mesh)

        Mesh.create_quad(Vector3(0, 0, size[2] * 0.5),
                         Vector3(-size[0] * 0.5, 0),
                         Vector3(0, size[1] * 0.5, 0), mesh)
        Mesh.create_quad(Vector3(0, 0, -size[2] * 0.5),
                         Vector3(size[0] * 0.5, 0),
                         Vector3(0, size[1] * 0.5, 0), mesh)

        return mesh

    @staticmethod
    def create_sphere(size, res_lat, res_lon, mesh=None):
        &#34;&#34;&#34;
        Adds the polygons necessary to form a sphere with the given size and resolution.
         If a source mesh is not given, a new mesh is created.
        This sphere will be centered on the origin (0,0,0).

        Arguments:

            size {3-tuple} -- (x,y,z) size of the sphere
            or
            size {number} -- radius of the sphere

            res_lat {int} -- Number of subdivisions in the latitude axis

            res_lon {int} -- Number of subdivisions in the longitudinal axis

            mesh {Mesh} -- Mesh to add the polygons. If not given, create a new mesh

        Returns:
            {Mesh} - Mesh where the polygons were added
        &#34;&#34;&#34;
        # Create mesh if one was not given
        if mesh is None:
            mesh = Mesh(&#34;UnknownSphere&#34;)

        # Compute half-size
        if isinstance(size, Vector3):
            hs = size * 0.5
        else:
            hs = Vector3(size[0], size[1], size[2]) * 0.5

        # Sphere is going to be composed by quads in most of the surface, but triangles near the
        # poles, so compute the bottom and top vertex
        bottom_vertex = Vector3(0, -hs.y, 0)
        top_vertex = Vector3(0, hs.y, 0)

        lat_inc = math.pi / res_lat
        lon_inc = math.pi * 2 / res_lon
        # First row of triangles
        lat = -math.pi / 2
        lon = 0

        y = hs.y * math.sin(lat + lat_inc)
        c = math.cos(lat + lat_inc)
        for _ in range(0, res_lon):
            p1 = Vector3(c * math.cos(lon) * hs.x, y, c * math.sin(lon) * hs.z)
            p2 = Vector3(c * math.cos(lon + lon_inc) * hs.x, y, c * math.sin(lon + lon_inc) * hs.z)

            Mesh.create_tri(bottom_vertex, p1, p2, mesh)

            lon += lon_inc

        # Quads in the middle
        for _ in range(1, res_lat - 1):
            lat += lat_inc

            y1 = hs.y * math.sin(lat)
            y2 = hs.y * math.sin(lat + lat_inc)
            c1 = math.cos(lat)
            c2 = math.cos(lat + lat_inc)

            lon = 0
            for _ in range(0, res_lon):
                p1 = Vector3(c1 * math.cos(lon) * hs.x,
                             y1,
                             c1 * math.sin(lon) * hs.z)
                p2 = Vector3(c1 * math.cos(lon + lon_inc) * hs.x,
                             y1,
                             c1 * math.sin(lon + lon_inc) * hs.z)
                p3 = Vector3(c2 * math.cos(lon) * hs.x,
                             y2,
                             c2 * math.sin(lon) * hs.z)
                p4 = Vector3(c2 * math.cos(lon + lon_inc) * hs.x,
                             y2,
                             c2 * math.sin(lon + lon_inc) * hs.z)

                poly = []
                poly.append(p1)
                poly.append(p2)
                poly.append(p4)
                poly.append(p3)

                mesh.polygons.append(poly)

                lon += lon_inc

        # Last row of triangles
        lat += lat_inc
        y = hs.y * math.sin(lat)
        c = math.cos(lat)
        for _ in range(0, res_lon):
            p1 = Vector3(c * math.cos(lon) * hs.x, y, c * math.sin(lon) * hs.z)
            p2 = Vector3(c * math.cos(lon + lon_inc) * hs.x, y, c * math.sin(lon + lon_inc) * hs.z)

            Mesh.create_tri(top_vertex, p1, p2, mesh)

            lon += lon_inc

        return mesh


    @staticmethod
    def create_quad(origin, axis0, axis1, mesh):
        &#34;&#34;&#34;
        Adds the vertices necessary to create a quad (4 sided coplanar rectangle).
        If a source mesh is not given, a new mesh is created.

        Arguments:

            origin {Vector3} -- Center of the quad

            axis0 {Vector3} -- One of the axis of the quad. This is not normalized, since the
            length specifies half the length of that side along that axis

            axis1 {Vector3} -- One of the axis of the quad. This is not normalized, since the
            length specifies half the length of that side along that axis

            mesh {Mesh} -- Mesh to add the polygons. If not given, create a new mesh

        Returns:
            {Mesh} - Mesh where the polygons were added
        &#34;&#34;&#34;
        if mesh is None:
            mesh = Mesh(&#34;UnknownQuad&#34;)

        poly = []
        poly.append(origin + axis0 + axis1)
        poly.append(origin + axis0 - axis1)
        poly.append(origin - axis0 - axis1)
        poly.append(origin - axis0 + axis1)

        mesh.polygons.append(poly)

        return mesh

    @staticmethod
    def create_tri(p1, p2, p3, mesh):
        &#34;&#34;&#34;
        Adds the vertices necessary to create a triangle
        If a source mesh is not given, a new mesh is created.

        Arguments:

            p1 {Vector3} -- First vertex of the triangle

            p2 {Vector3} -- Second vertex of the triangle

            p3 {Vector3} -- Third vertex of the triangle

            mesh {Mesh} -- Mesh to add the polygons. If not given, create a new mesh

        Returns:
            {Mesh} - Mesh where the polygons were added
        &#34;&#34;&#34;
        if mesh is None:
            mesh = Mesh(&#34;UnknownQuad&#34;)

        poly = []
        poly.append(p1)
        poly.append(p2)
        poly.append(p3)

        mesh.polygons.append(poly)

        return mesh</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pyxyz.mesh.Mesh.stat_render_time"><code class="name">var <span class="ident">stat_render_time</span></code></dt>
<dd>
<div class="desc"><p>Time spent in rendering for statistics. This code that actually tracks the statistics
is normally commented out for performance reasons (see render method)</p></div>
</dd>
<dt id="pyxyz.mesh.Mesh.stat_transform_time"><code class="name">var <span class="ident">stat_transform_time</span></code></dt>
<dd>
<div class="desc"><p>Time spent on vertex transforming for statistics. This code that actually tracks
the statistics is normally commented out for performance reasons (see render method)</p></div>
</dd>
<dt id="pyxyz.mesh.Mesh.stat_vertex_count"><code class="name">var <span class="ident">stat_vertex_count</span></code></dt>
<dd>
<div class="desc"><p>Vertex count for statistics. This code that actually tracks the statistics
is normally commented out for performance reasons (see render method)</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="pyxyz.mesh.Mesh.create_cube"><code class="name flex">
<span>def <span class="ident">create_cube</span></span>(<span>size, mesh=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the 6 polygons necessary to form a cube with the given size. If a source mesh is
not given, a new mesh is created.
This cube will be centered on the origin (0,0,0).</p>
<h2 id="arguments">Arguments</h2>
<p>size {3-tuple} &ndash; (x,y,z) size of the cube</p>
<p>mesh {Mesh} &ndash; Mesh to add the polygons. If not given, create a new mesh</p>
<h2 id="returns">Returns</h2>
<p>{Mesh} - Mesh where the polygons were added</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create_cube(size, mesh=None):
    &#34;&#34;&#34;
    Adds the 6 polygons necessary to form a cube with the given size. If a source mesh is
    not given, a new mesh is created.
    This cube will be centered on the origin (0,0,0).

    Arguments:

        size {3-tuple} -- (x,y,z) size of the cube

        mesh {Mesh} -- Mesh to add the polygons. If not given, create a new mesh

    Returns:
        {Mesh} - Mesh where the polygons were added
    &#34;&#34;&#34;

    # Create mesh if one was not given
    if mesh is None:
        mesh = Mesh(&#34;UnknownCube&#34;)

    # Add the 6 quads that create a cube
    Mesh.create_quad(Vector3(size[0] * 0.5, 0, 0),
                     Vector3(0, -size[1] * 0.5, 0),
                     Vector3(0, 0, size[2] * 0.5), mesh)
    Mesh.create_quad(Vector3(-size[0] * 0.5, 0, 0),
                     Vector3(0, size[1] * 0.5, 0),
                     Vector3(0, 0, size[2] * 0.5), mesh)

    Mesh.create_quad(Vector3(0, size[1] * 0.5, 0),
                     Vector3(size[0] * 0.5, 0),
                     Vector3(0, 0, size[2] * 0.5), mesh)
    Mesh.create_quad(Vector3(0, -size[1] * 0.5, 0),
                     Vector3(-size[0] * 0.5, 0),
                     Vector3(0, 0, size[2] * 0.5), mesh)

    Mesh.create_quad(Vector3(0, 0, size[2] * 0.5),
                     Vector3(-size[0] * 0.5, 0),
                     Vector3(0, size[1] * 0.5, 0), mesh)
    Mesh.create_quad(Vector3(0, 0, -size[2] * 0.5),
                     Vector3(size[0] * 0.5, 0),
                     Vector3(0, size[1] * 0.5, 0), mesh)

    return mesh</code></pre>
</details>
</dd>
<dt id="pyxyz.mesh.Mesh.create_quad"><code class="name flex">
<span>def <span class="ident">create_quad</span></span>(<span>origin, axis0, axis1, mesh)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the vertices necessary to create a quad (4 sided coplanar rectangle).
If a source mesh is not given, a new mesh is created.</p>
<h2 id="arguments">Arguments</h2>
<p>origin {Vector3} &ndash; Center of the quad</p>
<p>axis0 {Vector3} &ndash; One of the axis of the quad. This is not normalized, since the
length specifies half the length of that side along that axis</p>
<p>axis1 {Vector3} &ndash; One of the axis of the quad. This is not normalized, since the
length specifies half the length of that side along that axis</p>
<p>mesh {Mesh} &ndash; Mesh to add the polygons. If not given, create a new mesh</p>
<h2 id="returns">Returns</h2>
<p>{Mesh} - Mesh where the polygons were added</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create_quad(origin, axis0, axis1, mesh):
    &#34;&#34;&#34;
    Adds the vertices necessary to create a quad (4 sided coplanar rectangle).
    If a source mesh is not given, a new mesh is created.

    Arguments:

        origin {Vector3} -- Center of the quad

        axis0 {Vector3} -- One of the axis of the quad. This is not normalized, since the
        length specifies half the length of that side along that axis

        axis1 {Vector3} -- One of the axis of the quad. This is not normalized, since the
        length specifies half the length of that side along that axis

        mesh {Mesh} -- Mesh to add the polygons. If not given, create a new mesh

    Returns:
        {Mesh} - Mesh where the polygons were added
    &#34;&#34;&#34;
    if mesh is None:
        mesh = Mesh(&#34;UnknownQuad&#34;)

    poly = []
    poly.append(origin + axis0 + axis1)
    poly.append(origin + axis0 - axis1)
    poly.append(origin - axis0 - axis1)
    poly.append(origin - axis0 + axis1)

    mesh.polygons.append(poly)

    return mesh</code></pre>
</details>
</dd>
<dt id="pyxyz.mesh.Mesh.create_sphere"><code class="name flex">
<span>def <span class="ident">create_sphere</span></span>(<span>size, res_lat, res_lon, mesh=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the polygons necessary to form a sphere with the given size and resolution.
If a source mesh is not given, a new mesh is created.
This sphere will be centered on the origin (0,0,0).</p>
<h2 id="arguments">Arguments</h2>
<p>size {3-tuple} &ndash; (x,y,z) size of the sphere
or
size {number} &ndash; radius of the sphere</p>
<p>res_lat {int} &ndash; Number of subdivisions in the latitude axis</p>
<p>res_lon {int} &ndash; Number of subdivisions in the longitudinal axis</p>
<p>mesh {Mesh} &ndash; Mesh to add the polygons. If not given, create a new mesh</p>
<h2 id="returns">Returns</h2>
<p>{Mesh} - Mesh where the polygons were added</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create_sphere(size, res_lat, res_lon, mesh=None):
    &#34;&#34;&#34;
    Adds the polygons necessary to form a sphere with the given size and resolution.
     If a source mesh is not given, a new mesh is created.
    This sphere will be centered on the origin (0,0,0).

    Arguments:

        size {3-tuple} -- (x,y,z) size of the sphere
        or
        size {number} -- radius of the sphere

        res_lat {int} -- Number of subdivisions in the latitude axis

        res_lon {int} -- Number of subdivisions in the longitudinal axis

        mesh {Mesh} -- Mesh to add the polygons. If not given, create a new mesh

    Returns:
        {Mesh} - Mesh where the polygons were added
    &#34;&#34;&#34;
    # Create mesh if one was not given
    if mesh is None:
        mesh = Mesh(&#34;UnknownSphere&#34;)

    # Compute half-size
    if isinstance(size, Vector3):
        hs = size * 0.5
    else:
        hs = Vector3(size[0], size[1], size[2]) * 0.5

    # Sphere is going to be composed by quads in most of the surface, but triangles near the
    # poles, so compute the bottom and top vertex
    bottom_vertex = Vector3(0, -hs.y, 0)
    top_vertex = Vector3(0, hs.y, 0)

    lat_inc = math.pi / res_lat
    lon_inc = math.pi * 2 / res_lon
    # First row of triangles
    lat = -math.pi / 2
    lon = 0

    y = hs.y * math.sin(lat + lat_inc)
    c = math.cos(lat + lat_inc)
    for _ in range(0, res_lon):
        p1 = Vector3(c * math.cos(lon) * hs.x, y, c * math.sin(lon) * hs.z)
        p2 = Vector3(c * math.cos(lon + lon_inc) * hs.x, y, c * math.sin(lon + lon_inc) * hs.z)

        Mesh.create_tri(bottom_vertex, p1, p2, mesh)

        lon += lon_inc

    # Quads in the middle
    for _ in range(1, res_lat - 1):
        lat += lat_inc

        y1 = hs.y * math.sin(lat)
        y2 = hs.y * math.sin(lat + lat_inc)
        c1 = math.cos(lat)
        c2 = math.cos(lat + lat_inc)

        lon = 0
        for _ in range(0, res_lon):
            p1 = Vector3(c1 * math.cos(lon) * hs.x,
                         y1,
                         c1 * math.sin(lon) * hs.z)
            p2 = Vector3(c1 * math.cos(lon + lon_inc) * hs.x,
                         y1,
                         c1 * math.sin(lon + lon_inc) * hs.z)
            p3 = Vector3(c2 * math.cos(lon) * hs.x,
                         y2,
                         c2 * math.sin(lon) * hs.z)
            p4 = Vector3(c2 * math.cos(lon + lon_inc) * hs.x,
                         y2,
                         c2 * math.sin(lon + lon_inc) * hs.z)

            poly = []
            poly.append(p1)
            poly.append(p2)
            poly.append(p4)
            poly.append(p3)

            mesh.polygons.append(poly)

            lon += lon_inc

    # Last row of triangles
    lat += lat_inc
    y = hs.y * math.sin(lat)
    c = math.cos(lat)
    for _ in range(0, res_lon):
        p1 = Vector3(c * math.cos(lon) * hs.x, y, c * math.sin(lon) * hs.z)
        p2 = Vector3(c * math.cos(lon + lon_inc) * hs.x, y, c * math.sin(lon + lon_inc) * hs.z)

        Mesh.create_tri(top_vertex, p1, p2, mesh)

        lon += lon_inc

    return mesh</code></pre>
</details>
</dd>
<dt id="pyxyz.mesh.Mesh.create_tri"><code class="name flex">
<span>def <span class="ident">create_tri</span></span>(<span>p1, p2, p3, mesh)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the vertices necessary to create a triangle
If a source mesh is not given, a new mesh is created.</p>
<h2 id="arguments">Arguments</h2>
<p>p1 {Vector3} &ndash; First vertex of the triangle</p>
<p>p2 {Vector3} &ndash; Second vertex of the triangle</p>
<p>p3 {Vector3} &ndash; Third vertex of the triangle</p>
<p>mesh {Mesh} &ndash; Mesh to add the polygons. If not given, create a new mesh</p>
<h2 id="returns">Returns</h2>
<p>{Mesh} - Mesh where the polygons were added</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create_tri(p1, p2, p3, mesh):
    &#34;&#34;&#34;
    Adds the vertices necessary to create a triangle
    If a source mesh is not given, a new mesh is created.

    Arguments:

        p1 {Vector3} -- First vertex of the triangle

        p2 {Vector3} -- Second vertex of the triangle

        p3 {Vector3} -- Third vertex of the triangle

        mesh {Mesh} -- Mesh to add the polygons. If not given, create a new mesh

    Returns:
        {Mesh} - Mesh where the polygons were added
    &#34;&#34;&#34;
    if mesh is None:
        mesh = Mesh(&#34;UnknownQuad&#34;)

    poly = []
    poly.append(p1)
    poly.append(p2)
    poly.append(p3)

    mesh.polygons.append(poly)

    return mesh</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="pyxyz.mesh.Mesh.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>{str} Name of the mesh</p></div>
</dd>
<dt id="pyxyz.mesh.Mesh.polygons"><code class="name">var <span class="ident">polygons</span></code></dt>
<dd>
<div class="desc"><p>{list[list[Vector3]]} List of lists of polygons. A polygon is a closed shape,
hence the need for a list of lists, if we want more complex shapes.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyxyz.mesh.Mesh.offset"><code class="name flex">
<span>def <span class="ident">offset</span></span>(<span>self, v)</span>
</code></dt>
<dd>
<div class="desc"><p>Offsets this mesh by a given vector. In practice, adds v to all vertex in all polygons</p>
<h2 id="arguments">Arguments</h2>
<p>v {Vector3} &ndash; Ammount to displace the mesh</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def offset(self, v):
    &#34;&#34;&#34;
    Offsets this mesh by a given vector. In practice, adds v to all vertex in all polygons

    Arguments:

        v {Vector3} -- Ammount to displace the mesh
    &#34;&#34;&#34;
    new_polys = []
    for poly in self.polygons:
        new_poly = []
        for p in poly:
            new_poly.append(p + v)
        new_polys.append(new_poly)

    self.polygons = new_polys</code></pre>
</details>
</dd>
<dt id="pyxyz.mesh.Mesh.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self, screen, clip_matrix, material)</span>
</code></dt>
<dd>
<div class="desc"><p>Renders the mesh.</p>
<h2 id="arguments">Arguments</h2>
<p>screen {pygame.surface} &ndash; Display surface on which to render the mesh</p>
<p>clip_matrix {np.array} &ndash; Clip matrix to use to convert the 3d local space coordinates
of the vertices to screen coordinates.</p>
<p>material {Material} &ndash; Material to be used to render the mesh</p>
<p>Note that this function has the code that tracks statistics for the vertex count and
render times, but it is normally commented out, for performance reasons. If you want
to use the statistics, uncomment the code on this funtion.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render(self, screen, clip_matrix, material):
    &#34;&#34;&#34;
    Renders the mesh.

    Arguments:

        screen {pygame.surface} -- Display surface on which to render the mesh

        clip_matrix {np.array} -- Clip matrix to use to convert the 3d local space coordinates
        of the vertices to screen coordinates.

        material {Material} -- Material to be used to render the mesh

        Note that this function has the code that tracks statistics for the vertex count and
        render times, but it is normally commented out, for performance reasons. If you want
        to use the statistics, uncomment the code on this funtion.
    &#34;&#34;&#34;
    # Convert Color to the pygame format
    c = material.Color.tuple3()

    # For all polygons
    for poly in self.polygons:
        # Create the list that will store (temporarily) the transformed vertices
        tpoly = []
        # Uncomment next 2 lines for statistics
        #Mesh.stat_vertex_count += len(poly)
        #t0 = time.time()
        for v in poly:
            # Convert the vertex to numpy format and multiply it by the clip matrix
            vout = v.to_np4()
            vout = vout @ clip_matrix

            # Finalize the transformation by converting the point from homogeneous NDC to
            # screen coordinates (divide by w, scale it by the viewport resolution and
            # offset it)
            tpoly.append((screen.get_width() * 0.5 + vout[0] / vout[3],
                          screen.get_height() * 0.5 - vout[1] / vout[3]))

        # Uncomment next line for statistics
        #t1 = time.time()

        # Render
        pygame.draw.polygon(screen, c, tpoly, material.line_width)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyxyz" href="index.html">pyxyz</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyxyz.mesh.Mesh" href="#pyxyz.mesh.Mesh">Mesh</a></code></h4>
<ul class="two-column">
<li><code><a title="pyxyz.mesh.Mesh.create_cube" href="#pyxyz.mesh.Mesh.create_cube">create_cube</a></code></li>
<li><code><a title="pyxyz.mesh.Mesh.create_quad" href="#pyxyz.mesh.Mesh.create_quad">create_quad</a></code></li>
<li><code><a title="pyxyz.mesh.Mesh.create_sphere" href="#pyxyz.mesh.Mesh.create_sphere">create_sphere</a></code></li>
<li><code><a title="pyxyz.mesh.Mesh.create_tri" href="#pyxyz.mesh.Mesh.create_tri">create_tri</a></code></li>
<li><code><a title="pyxyz.mesh.Mesh.name" href="#pyxyz.mesh.Mesh.name">name</a></code></li>
<li><code><a title="pyxyz.mesh.Mesh.offset" href="#pyxyz.mesh.Mesh.offset">offset</a></code></li>
<li><code><a title="pyxyz.mesh.Mesh.polygons" href="#pyxyz.mesh.Mesh.polygons">polygons</a></code></li>
<li><code><a title="pyxyz.mesh.Mesh.render" href="#pyxyz.mesh.Mesh.render">render</a></code></li>
<li><code><a title="pyxyz.mesh.Mesh.stat_render_time" href="#pyxyz.mesh.Mesh.stat_render_time">stat_render_time</a></code></li>
<li><code><a title="pyxyz.mesh.Mesh.stat_transform_time" href="#pyxyz.mesh.Mesh.stat_transform_time">stat_transform_time</a></code></li>
<li><code><a title="pyxyz.mesh.Mesh.stat_vertex_count" href="#pyxyz.mesh.Mesh.stat_vertex_count">stat_vertex_count</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>